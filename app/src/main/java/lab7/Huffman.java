/*
 * This source file was generated by the Gradle 'init' task
 */
/*
 * Griffin Brauser
 * Danii Bolgar
 */
package lab7;

import java.util.Scanner;
import java.io.IOException;
import java.io.File;
import java.util.HashMap;
import java.util.Map;
import heap.Heap;
import java.util.PriorityQueue;

public class Huffman {

    private static class Node implements Comparable<Node> {
        // frequency sum
        final int freq;
        // the character for leaf nodes, null if non leaf node
        final Character ch;
        // childeren, null if leaf node
        final Node left, right;

        // constructs a leaf node for a given character and frequency
        Node(Character ch, int freq) {
            this.ch = ch;
            this. freq = freq;
            this.left = null;
            this.right = null;
        }

        // contructs parent node
        Node(Node left, Node right) {
            this.ch = null;
            this.freq = left.freq + right.freq;
            this.left = left;
            this.right = right;
        }

        // compare frequencies of nodes
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.freq, other.freq);
        }

        //check if node is a leaf
        boolean isLeaf() {
            return ch != null;
        }
    }

    public static void main(String[] args) throws IOException{
        String fileName = args[0];
        Scanner scanner = new Scanner(new File(fileName));
        StringBuilder inputBuilder = new StringBuilder();

        //read thru input file line by line
        while(scanner.hasNextLine()) {
            inputBuilder.append(scanner.nextLine());
            if(scanner.hasNextLine()) {
                inputBuilder.append("\n"); // preserve new lines
            }
        }
        scanner.close();
        String input = inputBuilder.toString();

        if(input.isEmpty()){
            System.out.println("Input is empty");
            return;
        }
        // count frequency, build tree, then encode and decode
        Map<Character, Integer> freqMap = new Huffman().countFreq(input);
        Node root = buildTree(freqMap);
        String encoded = encode(root, input);
        String decoded = decode(root, encoded);

        // print full results if small input
        if(input.length() < 100) {
            System.out.println("Input string: " + input);
            System.out.println("Encoded string: " + encoded);
            System.out.println("Decoded string: " + decoded);
        }

        // print summary of ressults and compression ratio
        System.out.println("Decoded equals input: " + decoded.equals(input));
        double compressRatio = ((double) encoded.length() / (input.length()) / 8.);
        System.out.println("Compression ratio: " + compressRatio);
    }

    // count the frequency of each character in the input string
    private Map<Character, Integer> countFreq(String input){
        Map<Character, Integer> freqMap = new HashMap<>(); 
        for(int i = 0; i < input.length(); i++){
            char c = input.charAt(i);
            // read the old count (or zero if absent) then add 1
            int previous = freqMap.getOrDefault(c,0);
            freqMap.put(c, previous + 1);
        }
        return freqMap;
    }

    /*
     * Build Huffman tree from frequency map
     * Uses priorityQueue to combine two lowest frequency nodes
     */
    private static Node buildTree (Map<Character, Integer> freqMap) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        //create a leaf node for each character and add it to the priority queue
        for (Map.Entry<Character, Integer> entry : freqMap.entrySet()) {
            pq.add(new Node(entry.getKey(), entry.getValue()));
        }

        // combine trees until only one tree remains
        while (pq.size() > 1) {
            Node left = pq.poll();
            Node right = pq.poll();
            Node parent = new Node(left, right);
            pq.add(parent);
        }

        return pq.poll();
    }

    // recursivley build binary codes for each character
    private static void buildBinaryMap(Node node, String prefix, Map<Character, String> binaryMap) {
        // base case: if a leaf is reached, record the prefix
        if (node.isLeaf()) {
            // checks for edge case of input being only one character
            binaryMap.put(node.ch, prefix.isEmpty() ? "0" : prefix);
            return;
        }

        // traverse left subtree
        buildBinaryMap(node.left, prefix + '0', binaryMap);
        // traverse right subtree
        buildBinaryMap(node.right, prefix + '1', binaryMap);
    }

    // get binary codes for all characters in the tree
    private static  Map<Character, String> getBinaryCode(Node root) {
        Map<Character, String> binaryMap = new HashMap<>();
        if (root != null) {
            buildBinaryMap(root, "", binaryMap);
        }
        return binaryMap;
    }

    private static String encode(Node root, String input) {
        StringBuilder encoded = new StringBuilder(input.length() * 2);
        Map<Character, String> binaryMap = getBinaryCode(root);

        for (char c : input.toCharArray()) {
            encoded.append(binaryMap.get(c));
        }
        return encoded.toString();
    }
    private static String decode(Node root, String bits) {
        StringBuilder decoded = new StringBuilder(bits.length() / 2);
        Node current = root;

        for (char bit : bits.toCharArray()) {
            // if 0, go left, if 1 (else), go right
            if (bit == '0') {
                current = current.left;
            } else {
                current = current.right;
            }
            //if Leaf, get character
            if (current.isLeaf()) {
                decoded.append(current.ch);
                current = root; // reset to root for next character
            }
        }
        return decoded.toString();
    }
}