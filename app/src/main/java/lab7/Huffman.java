/*
 * This source file was generated by the Gradle 'init' task
 */
/*
 * Griffin Brauser
 * Danii Bolgar
 */
package lab7;

import java.util.Scanner;
import java.io.IOException;
import java.io.File;
import java.util.HashMap;
import java.util.Map;
import heap.Heap;

public class Huffman {

    private static class Node implements Comparable<Node> {
        // frequency sum
        final int freq;
        // the character for leaf nodes, null if non leaf node
        final Character ch;
        // childeren, null if leaf node
        final Node left, right;

        // constructs a leaf node for a given character and frequency
        Node(Character ch, int freq) {
            this.ch = ch;
            this. freq = freq;
            this.left = null;
            this.right = null;
        }

        // contructs parent node
        Node(Node left, Node right) {
            this.ch = null;
            this.freq = left.freq + right.freq;
            this.left = left;
            this.right = right;
        }

        // compare frequencies of nodes
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.freq, other.freq);
        }

        //check if node is a leaf
        boolean isLeaf() {
            return ch != null;
        }
    }

    public static void main(String[] args) throws IOException{
        String fileName = args[0];
        Scanner scanner = new Scanner(new File(fileName));

        String input = scanner.nextLine();

        if(input.length() < 100){

        }
    }

    // count the frequency of each character in the input string
    private Map<Character, Integer> countFreq(String input){
        Map<Character, Integer> freqMap = new HashMap<>(); 
        for(int i = 0; i < input.length(); i++){
            char c = input.charAt(i);
            // read the old count (or zero if absent) then add 1
            int previous = freqMap.getOrDefault(c,0);
            freqMap.put(c, previous + 1);
        }
        return freqMap;
    }

    /*
     * Build Huffman tree from frequency map
     * Uses priorityQueue to combine two lowest frequency nodes
     */
    private static Node buildTree (Map<Character, Integer> freqMap) {
        PriorityQueue<Node> pq = new PriorityQueue<>();
        //create a leaf node for each character and add it to the priority queue
        for (Map.Entry<Character, Integer> entry : freqMap.entrySet()) {
            pq.add(new Node(entry.getKey(), entry.getValue()));
        }

        // combine trees until only one tree remains
        while (pq.size() > 1) {
            Node left = pq.poll();
            Node right = pq.poll();
            Node parent = new Node(left, right);
            pq.add(parent);
        }

        return pq.poll();
    }

    // recursivley build binary codes for each character
    private static void buildBinaryMap(Node node, String prefix, Map<Character, String> binaryMap) {
        // base case: if a leaf is reached, record the prefix
        if (node.isLeaf()) {
            // checks for edge case of input being only one character
            binaryMap.put(node.ch, prefix.isEmpty() ? "0" : prefix);
            return;
        }

        // traverse left subtree
        buildBinaryMap(node.left, prefix + '0', binaryMap);
        // traverse right subtree
        buildBinaryMap(node.right, prefix + '1', binaryMap);
    }

    // get binary codes for all characters in the tree
    private static  Map<Character, String> getBinaryCode(Node root) {
        Map<Character, String> binaryMap = new HashMap<>();
        if (root != null) {
            buildBinaryMap(root, "", binaryMap);
        }
        return binaryMap;
    }
}